<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>POLARITY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, #ff00ff22, transparent 70%);
            pointer-events: none;
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .container {
            text-align: center;
            padding: 0;
            position: relative;
            z-index: 1;
        }

        @media (max-height: 750px) {
            .container {
                transform: scale(0.8);
            }
            h1 {
                font-size: 2em;
                margin-bottom: 0;
            }
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 0;
            letter-spacing: 20px;
            background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            filter: drop-shadow(0 0 30px #ff00ff) drop-shadow(0 0 60px #00ffff);
            font-weight: 900;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5em;
                letter-spacing: 10px;
                margin-bottom: 0;
            }
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-wrapper {
            position: relative;
            display: inline-block;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            box-shadow: 
                0 0 50px rgba(255, 0, 255, 0.6),
                0 0 100px rgba(0, 255, 255, 0.4);
        }

        #gameCanvas {
            display: block;
            background: #000;
            border: 4px solid;
            border-image: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff) 1;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            #gameCanvas {
                border-width: 2px;
                max-height: 70vh;
            }
        }

        .info {
            margin-top: 0;
            font-size: 1.2em;
            display: flex;
            justify-content: space-around;
            max-width: 400px;
            gap: 20px;
        }

        .score, .combo {
            font-size: 1.4em;
            font-weight: 900;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 20px #ff00ff);
        }

        .game-over, .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(20px);
        }

        .hidden {
            display: none !important;
        }

        .game-over h2 {
            font-size: 4em;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #ff0055, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 40px #ff0055);
        }

        .start-screen h2 {
            font-size: 3em;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 40px #00ffff);
        }

        .game-over p, .start-screen p {
            font-size: 1.3em;
            margin-bottom: 12px;
            color: #fff;
            text-shadow: 0 0 20px #ff00ff;
        }

        .final-stats {
            margin: 30px 0;
            font-size: 1.6em;
        }

        .restart-hint {
            color: #888 !important;
            font-size: 0.9em !important;
            text-shadow: none !important;
        }

        button {
            margin: 10px;
            padding: 18px 50px;
            font-size: 1.4em;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #ff00ff, #00ffff);
            color: #000;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 40px rgba(255, 0, 255, 0.6), 0 0 80px rgba(0, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 60px rgba(255, 0, 255, 1), 0 0 120px rgba(0, 255, 255, 0.6);
        }

        .button-secondary {
            background: #333;
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            padding: 12px 30px;
            font-size: 1em;
        }

        .button-secondary:hover {
            background: #444;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
        }

        .instructions {
            margin-top: 0;
            color: #888;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 768px) {
            .instructions {
                font-size: 0.7em;
            }
        }

        .mobile-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            color: rgba(255, 255, 255, 0.8);
            animation: tapHint 2s ease-in-out infinite;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        @keyframes tapHint {
            0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        }

        @media (max-width: 768px) {
            .mobile-hint {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>POLARITY</h1>
        <div class="game-wrapper">
            <canvas id="gameCanvas" width="700" height="900"></canvas>
            
            <!-- Game Over Screen -->
            <div id="gameOver" class="game-over hidden">
                <h2>GAME OVER</h2>
                <div class="final-stats">
                    <p>SCORE: <span id="finalScore" style="color: #ff00ff;">0</span></p>
                    <p>HIGH SCORE: <span id="displayHighScore" style="color: #ffff00;">0</span></p>
                </div>
                <div style="margin: 20px 0;">
                    <button id="playAgainBtn" onclick="startGame()">ðŸ”„ PLAY AGAIN ðŸ”„</button>
                    <button class="button-secondary" onclick="window.location.href='index.html'">â—€ BACK TO MENU</button>
                </div>
                <p class="restart-hint" style="font-size: 0.9em; margin-top: 10px;">or press SPACE</p>
            </div>
            
            <!-- Start Screen -->
            <div id="startScreen" class="start-screen">
                <h2>â—¤ POLARITY â—¢</h2>
                <p id="startInstructions1">â–¸ PRESS SPACE TO SWITCH (+5) â—‚</p>
                <p>â–¸ AVOID OBSTACLES â—‚</p>
                <p>â–¸ SURVIVE â—‚</p>
                <button id="startBtn">âš¡ START âš¡</button>
                <button class="button-secondary" onclick="window.location.href='index.html'">â—€ BACK TO MENU</button>
            </div>
        </div>
        <div class="info">
            <div class="score">SCORE: <span id="score">0</span></div>
            <div class="combo" id="comboDisplay" style="display: none;">COMBO: <span id="combo">0</span>x</div>
        </div>
        <div class="instructions">
            <span id="controlHint">â—† SPACEBAR TO SWITCH (+5 PTS) â—† SURVIVE â—†</span>
            <button class="button-secondary" onclick="toggleSound()" style="padding: 5px 15px; font-size: 0.8em; margin-left: 10px;">ðŸ”Š SOUND: <span id="soundStatus">ON</span></button>
        </div>
    </div>
    <div id="mobileHint" class="mobile-hint">ðŸ‘† TAP TO SWITCH</div>
    <script>
        // ===== AUDIO SYSTEM =====
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let soundEnabled = true;

        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            switch(type) {
                case 'switch':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                    
                case 'close':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                    
                case 'closer':
                    oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
                    
                case 'insane':
                    oscillator.frequency.setValueAtTime(1400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;
                    
                case 'combo':
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
                    
                case 'death':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.5);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundStatus').textContent = soundEnabled ? 'ON' : 'OFF';
            localStorage.setItem('soundEnabled', soundEnabled);
        }

        // Load sound preference
        const savedSound = localStorage.getItem('soundEnabled');
        if (savedSound !== null) {
            soundEnabled = savedSound === 'true';
            document.getElementById('soundStatus').textContent = soundEnabled ? 'ON' : 'OFF';
        }

        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ===== GAME STATE =====
        let highScore = parseInt(localStorage.getItem('polarityHighScore') || '0');
        
        const gameState = {
            isPlaying: false,
            magnetSide: 0,
            magnetX: 40,
            magnetY: canvas.height / 2,
            targetY: canvas.height / 2,
            magnetVx: 0,
            magnetVy: 0,
            magnetRotation: -Math.PI / 2,
            targetRotation: -Math.PI / 2,
            obstacles: [],
            particles: [],
            floatingTexts: [],
            score: 0,
            combo: 0,
            maxCombo: 0,
            screenShake: 0,
            speed: 2,
            switches: 0,
            nearMisses: 0
        };

        // ===== MOBILE DETECTION =====
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // ===== GAME CONSTANTS =====
        const MAGNET_SIZE = 30;
        const WALL_WIDTH = 20;
        const OBSTACLE_WIDTH = 60;
        const OBSTACLE_HEIGHT = 60;
        const SWITCH_SPEED = 18;

        // ===== PARTICLES =====
        function createParticles(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                gameState.particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    decay: Math.random() * 0.02 + 0.01,
                    color,
                    size: Math.random() * 4 + 2
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                p.vy += 0.2;
                return p.life > 0;
            });
        }

        function drawParticles() {
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }

        // ===== FLOATING TEXT =====
        function createFloatingText(text, x, y, color) {
            gameState.floatingTexts.push({ text, x, y, vy: -2, life: 1, color });
        }

        function updateFloatingTexts() {
            gameState.floatingTexts = gameState.floatingTexts.filter(t => {
                t.y += t.vy;
                t.life -= 0.02;
                return t.life > 0;
            });
        }

        function drawFloatingTexts() {
            gameState.floatingTexts.forEach(t => {
                ctx.globalAlpha = t.life;
                ctx.fillStyle = t.color;
                ctx.font = 'bold 20px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(t.text, t.x, t.y);
            });
            ctx.globalAlpha = 1;
        }

        // ===== OBSTACLES =====
        function spawnObstacle() {
            const side = Math.random() > 0.5 ? 0 : 1;
            const x = side === 0 ? WALL_WIDTH : canvas.width - WALL_WIDTH - OBSTACLE_WIDTH;
            const y = Math.random() * (canvas.height - OBSTACLE_HEIGHT - 100) + 50;
            
            const types = ['ðŸ”©', 'ðŸ”§', 'âš™ï¸', 'ðŸ”¨', 'âš¡', 'ðŸ’Ž'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            gameState.obstacles.push({ x, y, side, type, passed: false });
        }

        function updateObstacles() {
            gameState.obstacles.forEach(obs => {
                obs.y += gameState.speed;
                
                // Check near miss
                if (!obs.passed && gameState.magnetSide !== obs.side && 
                    Math.abs(gameState.magnetY - (obs.y + OBSTACLE_HEIGHT / 2)) < 80) {
                    
                    const distance = Math.abs(gameState.magnetY - (obs.y + OBSTACLE_HEIGHT / 2));
                    let points = 0;
                    let label = '';
                    let soundType = '';
                    
                    if (distance < 30) {
                        points = 15;
                        label = '+15 INSANE!';
                        soundType = 'insane';
                        gameState.nearMisses++;
                    } else if (distance < 50) {
                        points = 10;
                        label = '+10 CLOSER!';
                        soundType = 'closer';
                        gameState.nearMisses++;
                    } else {
                        points = 5;
                        label = '+5 CLOSE!';
                        soundType = 'close';
                    }
                    
                    gameState.score += points;
                    gameState.combo++;
                    createFloatingText(label, canvas.width / 2, obs.y, '#00ffff');
                    playSound(soundType);
                    obs.passed = true;
                    
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }
                    
                    // Combo milestone bonuses
                    if (gameState.combo === 10 || gameState.combo === 25 || gameState.combo === 50) {
                        const bonus = gameState.combo * 10;
                        gameState.score += bonus;
                        createFloatingText(`ðŸ”¥ ${gameState.combo}x COMBO! +${bonus}`, canvas.width / 2, canvas.height / 2, '#ffaa00');
                        playSound('combo');
                    }
                }
            });
            
            gameState.obstacles = gameState.obstacles.filter(obs => obs.y < canvas.height + 100);
            
            if (gameState.obstacles.length < 3) {
                spawnObstacle();
            }
        }

        function checkCollision() {
            for (let obs of gameState.obstacles) {
                if (obs.side === gameState.magnetSide) {
                    const dx = (gameState.magnetX + MAGNET_SIZE / 2) - (obs.x + OBSTACLE_WIDTH / 2);
                    const dy = (gameState.magnetY + MAGNET_SIZE / 2) - (obs.y + OBSTACLE_HEIGHT / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < (MAGNET_SIZE + OBSTACLE_WIDTH) / 2) {
                        return true;
                    }
                }
            }
            return false;
        }

        function drawObstacles() {
            gameState.obstacles.forEach(obs => {
                ctx.font = `${OBSTACLE_WIDTH}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(obs.type, obs.x + OBSTACLE_WIDTH / 2, obs.y + OBSTACLE_HEIGHT / 2);
            });
        }

        // ===== MAGNET =====
        function drawMagnet() {
            ctx.save();
            ctx.translate(gameState.magnetX + MAGNET_SIZE / 2, gameState.magnetY + MAGNET_SIZE / 2);
            ctx.rotate(gameState.magnetRotation);
            
            // U-shaped magnet
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-15, -20, 10, 40);
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(5, -20, 10, 40);
            ctx.fillStyle = '#888';
            ctx.fillRect(-15, 15, 30, 10);
            
            ctx.restore();
        }

        function switchSides() {
            if (!gameState.isPlaying) return;
            
            gameState.magnetSide = 1 - gameState.magnetSide;
            gameState.targetRotation = gameState.magnetSide === 0 ? -Math.PI / 2 : Math.PI / 2;
            gameState.targetY = canvas.height / 2;
            
            const targetX = gameState.magnetSide === 0 ? 40 : canvas.width - 40 - MAGNET_SIZE;
            gameState.magnetVx = (targetX - gameState.magnetX) / 10;
            
            gameState.score += 5;
            gameState.switches++;
            gameState.combo = 0;
            
            createParticles(gameState.magnetX + MAGNET_SIZE / 2, gameState.magnetY + MAGNET_SIZE / 2, 
                gameState.magnetSide === 0 ? '#ff00ff' : '#00ffff', 20);
            
            playSound('switch');
            gameState.screenShake = 5;
            
            document.getElementById('score').textContent = gameState.score;
            
            const comboDisplay = document.getElementById('comboDisplay');
            if (gameState.combo >= 5) {
                comboDisplay.style.display = 'block';
                document.getElementById('combo').textContent = gameState.combo;
            } else {
                comboDisplay.style.display = 'none';
            }
        }

        // ===== GAME LOOP =====
        function updateGame() {
            // Update magnet position
            gameState.magnetX += gameState.magnetVx;
            gameState.magnetVx *= 0.85;
            
            gameState.magnetY += (gameState.targetY - gameState.magnetY) * 0.1;
            gameState.magnetVy *= 0.9;
            
            // Smooth rotation
            let rotDiff = gameState.targetRotation - gameState.magnetRotation;
            while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
            while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
            gameState.magnetRotation += rotDiff * 0.15;
            
            // Update game elements
            updateObstacles();
            updateParticles();
            updateFloatingTexts();
            
            // Increase difficulty
            if (gameState.speed < 8) {
                gameState.speed += 0.001;
            }
            
            // Screen shake
            if (gameState.screenShake > 0) {
                gameState.screenShake *= 0.9;
                if (gameState.screenShake < 0.1) gameState.screenShake = 0;
            }
            
            // Collision detection
            if (checkCollision()) {
                gameOver();
            }
            
            // Update combo display
            const comboDisplay = document.getElementById('comboDisplay');
            if (gameState.combo >= 5) {
                comboDisplay.style.display = 'block';
                document.getElementById('combo').textContent = gameState.combo;
            } else {
                comboDisplay.style.display = 'none';
            }
        }

        function drawGame() {
            ctx.save();
            
            // Screen shake
            if (gameState.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * gameState.screenShake,
                    (Math.random() - 0.5) * gameState.screenShake
                );
            }
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Walls
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, WALL_WIDTH, canvas.height);
            ctx.fillRect(canvas.width - WALL_WIDTH, 0, WALL_WIDTH, canvas.height);
            
            // Obstacles
            drawObstacles();
            
            // Particles
            drawParticles();
            
            // Magnet
            drawMagnet();
            
            // Floating texts
            drawFloatingTexts();
            
            ctx.restore();
        }

        // ===== GAME CONTROL =====
        function startGame() {
            // Reset game state
            gameState.isPlaying = true;
            gameState.magnetSide = 0;
            gameState.magnetX = 40;
            gameState.magnetY = canvas.height / 2;
            gameState.targetY = canvas.height / 2;
            gameState.magnetVx = 0;
            gameState.magnetVy = 0;
            gameState.magnetRotation = -Math.PI / 2;
            gameState.targetRotation = -Math.PI / 2;
            gameState.obstacles = [];
            gameState.particles = [];
            gameState.floatingTexts = [];
            gameState.score = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.screenShake = 0;
            gameState.speed = 2;
            gameState.switches = 0;
            gameState.nearMisses = 0;
            
            document.getElementById('score').textContent = '0';
            document.getElementById('comboDisplay').style.display = 'none';
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            
            // Spawn initial obstacles
            for (let i = 0; i < 3; i++) {
                spawnObstacle();
            }
            
            gameLoop();
        }

        function gameOver() {
            playSound('death');
            createParticles(gameState.magnetX + MAGNET_SIZE / 2, gameState.magnetY + MAGNET_SIZE / 2, '#ff0055', 30);
            gameState.screenShake = 20;
            
            const gameOverScreen = document.getElementById('gameOver');
            const finalScoreElement = document.getElementById('finalScore');
            const displayHighScoreElement = document.getElementById('displayHighScore');
            
            gameState.isPlaying = false;
            finalScoreElement.textContent = gameState.score;
            
            if (gameState.score > highScore) {
                highScore = gameState.score;
                localStorage.setItem('polarityHighScore', highScore);
            }
            displayHighScoreElement.textContent = highScore;
            
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 200);
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            updateGame();
            drawGame();
            
            requestAnimationFrame(gameLoop);
        }

        // ===== INPUT HANDLING =====
        document.getElementById('startBtn').addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            startGame();
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                if (!gameState.isPlaying) {
                    const startScreen = document.getElementById('startScreen');
                    const gameOverScreen = document.getElementById('gameOver');
                    
                    if (!startScreen.classList.contains('hidden') || !gameOverScreen.classList.contains('hidden')) {
                        startGame();
                    }
                } else {
                    switchSides();
                }
            }
        });

        // Touch/Click controls
        canvas.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (gameState.isPlaying) {
                switchSides();
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (gameState.isPlaying) {
                switchSides();
            }
        });

        // Initialize
        drawGame();

        // Update UI for mobile
        if (isMobile) {
            document.getElementById('startInstructions1').textContent = 'â–¸ TAP SCREEN TO SWITCH (+5) â—‚';
            document.getElementById('controlHint').textContent = 'â—† TAP TO SWITCH (+5 PTS) â—† SURVIVE â—†';
            
            const maxWidth = Math.min(700, window.innerWidth - 20);
            const maxHeight = Math.min(900, window.innerHeight * 0.7);
            const scale = Math.min(maxWidth / 700, maxHeight / 900);
            
            if (scale < 1) {
                canvas.style.width = (700 * scale) + 'px';
                canvas.style.height = (900 * scale) + 'px';
            }
        }
    </script>
</body>
</html>
