<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>VELOCITY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .container {
            text-align: center;
            padding: 0;
            position: relative;
        }
        
            h1 {
                font-size: 2em !important;
                margin-bottom: 5px !important;
            }
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            letter-spacing: 20px;
            background: linear-gradient(90deg, #ff0055, #ff3366, #ff0055);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            font-weight: 900;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .game-wrapper {
            position: relative;
            display: inline-block;
            border-radius: 10px;
            overflow: hidden;
            background: #fff;
            box-shadow: 0 0 50px rgba(255, 0, 85, 0.4);
        }

        #gameCanvas {
            display: block;
            background: #fff;
            border: 4px solid #ff0055;
            cursor: none;
        }

        .info {
            margin-top: 0;
            font-size: 1.4em;
            font-weight: 900;
            color: #ff0055;
            text-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
        }

        .time-scale {
            margin-top: 10px;
            font-size: 1.2em;
            color: #666;
        }

        .game-over, .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .hidden {
            display: none !important;
        }

        .game-over h2 {
            font-size: 4em;
            color: #ff0055;
            text-shadow: 0 0 40px rgba(255, 0, 85, 0.8);
        }

        .start-screen h2 {
            font-size: 2.5em;
            color: #ff0055;
            text-shadow: 0 0 40px rgba(255, 0, 85, 0.8);
        }

        .game-over p, .start-screen p {
            font-size: 1.3em;
            margin: 15px 0;
            color: #333;
        }

        button {
            margin: 15px 10px;
            padding: 18px 50px;
            font-size: 1.4em;
            font-weight: 900;
            font-family: 'Orbitron', sans-serif;
            background: #ff0055;
            color: #fff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 40px rgba(255, 0, 85, 0.6);
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 60px rgba(255, 0, 85, 1);
        }

        .button-secondary {
            background: #666;
            padding: 12px 30px;
            font-size: 1em;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.5em; letter-spacing: 12px; }
            .info { font-size: 1.2em; }
            button { padding: 15px 35px; font-size: 1.2em; }
            .game-over h2 { font-size: 2.5em; }
            .start-screen h2 { font-size: 2em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>VELOCITY</h1>
        <div class="game-wrapper">
            <canvas id="gameCanvas" width="500" height="700"></canvas>
            
            <div id="gameOver" class="game-over hidden">
                <h2>TIME'S UP</h2>
                <p>SCORE: <span id="finalScore" style="color: #ff0055;">0</span></p>
                <p>SURVIVED: <span id="survivalTime" style="color: #333;">0s</span></p>
                <p>HIGH SCORE: <span id="highScoreDisplay" style="color: #ff0055;">0</span></p>
                <button onclick="startGame()">ðŸ”„ PLAY AGAIN ðŸ”„</button>
                <button class="button-secondary" onclick="window.location.href='index.html'">â—€ BACK TO MENU</button>
            </div>
            
            <div id="startScreen" class="start-screen">
                <h2>â–² VELOCITY â–²</h2>
                <p>âš¡ Time slows when you stand still</p>
                <p>ðŸŽ¯ Move your cursor/finger to dodge</p>
                <p>ðŸ’€ One hit = Game Over</p>
                <p style="font-size: 0.9em; color: #666;">ðŸ”º Chasers ðŸ”´ Snipers ðŸ”µ Turrets</p>
                <button id="startBtn">âš¡ START âš¡</button>
                <button class="button-secondary" onclick="window.location.href='index.html'">â—€ BACK</button>
            </div>
        </div>
        <div class="info">SCORE: <span id="score">0</span></div>
        <div class="time-scale">TIME SCALE: <span id="timeScale">100%</span></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const timeScaleElement = document.getElementById('timeScale');
        const finalScoreElement = document.getElementById('finalScore');
        const survivalTimeElement = document.getElementById('survivalTime');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const gameOverScreen = document.getElementById('gameOver');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         ('ontouchstart' in window);

        let highScore = parseInt(localStorage.getItem('velocityHighScore')) || 0;

        let gameState = {
            isPlaying: false,
            score: 0,
            survivalTime: 0,
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                targetX: canvas.width / 2,
                targetY: canvas.height / 2,
                radius: 12,
                velocityX: 0,
                velocityY: 0,
                speed: 0
            },
            timeScale: 1.0,
            targetTimeScale: 1.0,
            maxPlayerSpeed: 15,
            enemies: [],
            bullets: [],
            particles: [],
            spawnTimer: 0,
            spawnRate: 120, // frames
            difficulty: 1
        };

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        let soundEnabled = true;

        function playSound(freq, duration = 0.1, type = 'sine') {
            if (!soundEnabled) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = freq;
                osc.type = type;
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        // Input handling
        function updateMousePosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                gameState.player.targetX = (e.touches[0].clientX - rect.left) * scaleX;
                gameState.player.targetY = (e.touches[0].clientY - rect.top) * scaleY;
            } else {
                gameState.player.targetX = (e.clientX - rect.left) * scaleX;
                gameState.player.targetY = (e.clientY - rect.top) * scaleY;
            }
        }

        canvas.addEventListener('mousemove', updateMousePosition);
        canvas.addEventListener('touchmove', updateMousePosition, { passive: true });
        canvas.addEventListener('touchstart', (e) => {
            updateMousePosition(e);
            if (!gameState.isPlaying && startScreen.classList.contains('hidden')) {
                startGame();
            }
        });

        startBtn.addEventListener('click', startGame);

        // Enemy Classes
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.health = 1;
                this.radius = type === 'chaser' ? 10 : 15;
            }
        }

        class Chaser extends Enemy {
            constructor(x, y) {
                super(x, y, 'chaser');
                this.speed = 2;
                this.color = '#00ff44';
            }

            update(timeScale) {
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed * timeScale;
                    this.y += (dy / dist) * this.speed * timeScale;
                }
                
                // World movement (simulate forward motion)
                this.y += gameState.worldSpeed * timeScale;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const angle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                ctx.rotate(angle + Math.PI / 2);
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius * 0.8, this.radius * 0.8);
                ctx.lineTo(-this.radius * 0.8, this.radius * 0.8);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Sniper extends Enemy {
            constructor(x, y) {
                super(x, y, 'sniper');
                this.color = '#ff0055';
                this.aimTime = 0;
                this.aimDuration = 120; // 2 seconds at 60fps
                this.cooldown = 0;
                this.targetAngle = 0;
            }

            update(timeScale) {
                // World movement (simulate forward motion)
                this.y += gameState.worldSpeed * timeScale;
                
                if (this.cooldown > 0) {
                    this.cooldown -= timeScale;
                    return;
                }

                this.aimTime += timeScale;
                this.targetAngle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);

                if (this.aimTime >= this.aimDuration) {
                    this.shoot();
                    this.aimTime = 0;
                    this.cooldown = 180; // 3 second cooldown
                }
            }

            shoot() {
                const speed = 8;
                gameState.bullets.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(this.targetAngle) * speed,
                    vy: Math.sin(this.targetAngle) * speed,
                    radius: 4,
                    color: this.color,
                    type: 'sniper'
                });
                playSound(800, 0.1, 'square');
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.targetAngle + Math.PI / 2);
                
                // Laser sight when aiming
                if (this.cooldown <= 0 && this.aimTime > 0) {
                    const aimProgress = this.aimTime / this.aimDuration;
                    ctx.strokeStyle = `rgba(255, 0, 85, ${aimProgress * 0.6})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -500);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius * 0.8, this.radius * 0.8);
                ctx.lineTo(-this.radius * 0.8, this.radius * 0.8);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Turret extends Enemy {
            constructor(x, y) {
                super(x, y, 'turret');
                this.color = '#0088ff';
                this.angle = 0;
                this.rotationSpeed = 0.02;
                this.shootTimer = 0;
                this.shootInterval = 40; // shoot every 40 frames
            }

            update(timeScale) {
                // World movement (simulate forward motion)
                this.y += gameState.worldSpeed * timeScale;
                
                this.angle += this.rotationSpeed * timeScale;
                this.shootTimer += timeScale;

                if (this.shootTimer >= this.shootInterval) {
                    this.shoot();
                    this.shootTimer = 0;
                }
            }

            shoot() {
                const speed = 5;
                gameState.bullets.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(this.angle) * speed,
                    vy: Math.sin(this.angle) * speed,
                    radius: 4,
                    color: this.color,
                    type: 'turret'
                });
                playSound(600, 0.08, 'square');
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Base
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Rotating barrel
                ctx.rotate(this.angle);
                ctx.fillRect(-3, -this.radius - 8, 6, this.radius + 8);
                
                ctx.restore();
            }
        }

        function spawnEnemy() {
            const padding = 30;
            // Always spawn at top (moving forward through space)
            const x = padding + Math.random() * (canvas.width - padding * 2);
            const y = -50; // Spawn above screen

            // Random enemy type
            const types = ['chaser', 'sniper', 'turret'];
            const weights = [0.4, 0.3, 0.3]; // 40% chaser, 30% sniper, 30% turret
            const rand = Math.random();
            let type;
            
            if (rand < weights[0]) type = 'chaser';
            else if (rand < weights[0] + weights[1]) type = 'sniper';
            else type = 'turret';

            let enemy;
            if (type === 'chaser') enemy = new Chaser(x, y);
            else if (type === 'sniper') enemy = new Sniper(x, y);
            else enemy = new Turret(x, y);

            gameState.enemies.push(enemy);
        }

        function createParticles(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (3 + Math.random() * 4),
                    vy: Math.sin(angle) * (3 + Math.random() * 4),
                    life: 1,
                    color: color
                });
            }
        }

        function startGame() {
            gameState = {
                isPlaying: true,
                score: 0,
                survivalTime: 0,
                player: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    targetX: canvas.width / 2,
                    targetY: canvas.height / 2,
                    radius: 18,
                    velocityX: 0,
                    velocityY: 0,
                    speed: 0
                },
                timeScale: 1.0,
                targetTimeScale: 1.0,
                maxPlayerSpeed: 15,
                worldSpeed: 2,
                enemies: [],
                bullets: [],
                particles: [],
                spawnTimer: 0,
                spawnRate: 120,
                difficulty: 1
            };
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreElement.textContent = '0';
            timeScaleElement.textContent = '100%';
            highScoreDisplay.textContent = highScore;
            
            // Spawn initial enemies
            for (let i = 0; i < 3; i++) {
                setTimeout(() => spawnEnemy(), i * 500);
            }
            
            gameLoop();
        }

        function updateGame() {
            if (!gameState.isPlaying) return;

            gameState.survivalTime += 1/60;

            // Update player position (smooth follow)
            const dx = gameState.player.targetX - gameState.player.x;
            const dy = gameState.player.targetY - gameState.player.y;
            
            gameState.player.velocityX = dx * 0.2;
            gameState.player.velocityY = dy * 0.2;
            
            gameState.player.x += gameState.player.velocityX;
            gameState.player.y += gameState.player.velocityY;

            // Calculate player speed
            gameState.player.speed = Math.sqrt(
                gameState.player.velocityX * gameState.player.velocityX + 
                gameState.player.velocityY * gameState.player.velocityY
            );

            // Update time scale based on player speed
            const speedRatio = Math.min(gameState.player.speed / gameState.maxPlayerSpeed, 1);
            gameState.targetTimeScale = 0.1 + speedRatio * 0.9; // 10% to 100%
            gameState.timeScale += (gameState.targetTimeScale - gameState.timeScale) * 0.1;

            // Update particles
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.x += p.vx * gameState.timeScale;
                p.y += p.vy * gameState.timeScale;
                p.life -= 0.02 * gameState.timeScale;
                p.vx *= 0.97;
                p.vy *= 0.97;
                
                if (p.life <= 0) gameState.particles.splice(i, 1);
            }

            // Update enemies
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                enemy.update(gameState.timeScale);

                // Collision with player
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < enemy.radius + gameState.player.radius) {
                    createParticles(gameState.player.x, gameState.player.y, '#ff0055', 30);
                    playSound(100, 0.5);
                    endGame();
                    return;
                }
            }

            // Update bullets
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                bullet.x += bullet.vx * gameState.timeScale;
                bullet.y += bullet.vy * gameState.timeScale;
                
                // World movement (simulate forward motion)
                bullet.y += gameState.worldSpeed * gameState.timeScale;

                // Remove off-screen bullets
                if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
                    bullet.y < -50 || bullet.y > canvas.height + 50) {
                    gameState.bullets.splice(i, 1);
                    continue;
                }

                // Collision with chasers (friendly fire!)
                let bulletRemoved = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    if (enemy.type === 'chaser') {
                        const dx2 = bullet.x - enemy.x;
                        const dy2 = bullet.y - enemy.y;
                        const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        
                        if (dist2 < bullet.radius + enemy.radius) {
                            createParticles(enemy.x, enemy.y, enemy.color, 15);
                            gameState.enemies.splice(j, 1);
                            gameState.bullets.splice(i, 1);
                            gameState.score += 25; // Bonus for clever dodging!
                            scoreElement.textContent = gameState.score;
                            playSound(900, 0.1);
                            bulletRemoved = true;
                            break;
                        }
                    }
                }
                
                if (bulletRemoved) continue;

                // Collision with player
                const dx = bullet.x - gameState.player.x;
                const dy = bullet.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < bullet.radius + gameState.player.radius) {
                    createParticles(bullet.x, bullet.y, bullet.color, 15);
                    playSound(100, 0.5);
                    endGame();
                    return;
                }
            }

            // Spawn enemies
            gameState.spawnTimer++;
            if (gameState.spawnTimer >= gameState.spawnRate) {
                spawnEnemy();
                gameState.spawnTimer = 0;
                gameState.score += 10;
                scoreElement.textContent = gameState.score;
            }

            // Increase difficulty
            gameState.difficulty = 1 + gameState.survivalTime / 30;
            gameState.spawnRate = Math.max(40, 120 - gameState.survivalTime * 2);

            // Update UI
            timeScaleElement.textContent = Math.round(gameState.timeScale * 100) + '%';
        }

        function drawGame() {
            // Background - white, slightly gray when slow
            const bgGray = 255 - (1 - gameState.timeScale) * 30;
            ctx.fillStyle = `rgb(${bgGray}, ${bgGray}, ${bgGray})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Particles
            gameState.particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });

            // Bullets
            gameState.bullets.forEach(bullet => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = bullet.color;
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();

                // Trail
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(bullet.x - bullet.vx * 2, bullet.y - bullet.vy * 2, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Enemies
            gameState.enemies.forEach(enemy => enemy.draw());

            // Player
            const playerColor = '#000';
            ctx.save();
            ctx.translate(gameState.player.x, gameState.player.y);
            
            const angle = Math.atan2(gameState.player.velocityY, gameState.player.velocityX);
            ctx.rotate(angle + Math.PI / 2);
            
            ctx.shadowBlur = 30;
            ctx.shadowColor = playerColor;
            ctx.fillStyle = playerColor;
            ctx.beginPath();
            ctx.moveTo(0, -gameState.player.radius);
            ctx.lineTo(gameState.player.radius * 0.8, gameState.player.radius * 0.8);
            ctx.lineTo(-gameState.player.radius * 0.8, gameState.player.radius * 0.8);
            ctx.closePath();
            ctx.fill();
            
            // Motion trail
            if (gameState.player.speed > 3) {
                ctx.globalAlpha = Math.min(gameState.player.speed / 15, 0.5);
                for (let i = 1; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, -gameState.player.radius + i * 8);
                    ctx.lineTo(gameState.player.radius * 0.6, gameState.player.radius * 0.8 + i * 8);
                    ctx.lineTo(-gameState.player.radius * 0.6, gameState.player.radius * 0.8 + i * 8);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
        }

        function endGame() {
            gameState.isPlaying = false;
            finalScoreElement.textContent = gameState.score;
            survivalTimeElement.textContent = gameState.survivalTime.toFixed(1) + 's';
            
            if (gameState.score > highScore) {
                highScore = gameState.score;
                localStorage.setItem('velocityHighScore', highScore);
            }
            highScoreDisplay.textContent = highScore;
            
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 200);
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;
            
            updateGame();
            drawGame();
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        highScoreDisplay.textContent = highScore;
        
        // Draw initial state
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>
